"""
Multi-Table Detection Schema Models.
Defines the output of the TableDetectionAgent.
"""

from typing import List, Optional, Dict, Any, Literal, Tuple
from pydantic import BaseModel, Field


class TableBoundary(BaseModel):
    """Coordinates of a detected table within a sheet."""
    start_row: int = Field(description="0-indexed, inclusive start row")
    end_row: int = Field(description="0-indexed, inclusive end row")
    start_col: int = Field(description="0-indexed, inclusive start column")
    end_col: int = Field(description="0-indexed, inclusive end column")
    
    @property
    def row_count(self) -> int:
        """Number of rows in the table."""
        return self.end_row - self.start_row + 1
    
    @property
    def col_count(self) -> int:
        """Number of columns in the table."""
        return self.end_col - self.start_col + 1


class DetectedTable(BaseModel):
    """A single table detected in the Excel file."""
    table_id: str = Field(description="Unique identifier, e.g., 'table_001'")
    title: Optional[str] = Field(
        default=None, 
        description="Detected title/header above the table if present"
    )
    boundary: TableBoundary = Field(description="Table coordinates in the sheet")
    header_row: int = Field(
        default=0, 
        description="Row index of headers relative to boundary.start_row"
    )
    column_count: int = Field(default=0, description="Number of columns")
    row_count: int = Field(default=0, description="Number of data rows (excluding header)")
    column_names: List[str] = Field(
        default_factory=list, 
        description="Detected column headers"
    )
    sample_values: Dict[str, List[str]] = Field(
        default_factory=dict,
        description="Sample values for each column (max 5)"
    )
    table_type: Literal["data_table", "summary", "metadata", "unknown"] = Field(
        default="data_table",
        description="Classification of table type"
    )
    confidence: float = Field(
        default=0.8,
        ge=0.0,
        le=1.0,
        description="Detection confidence score"
    )
    
    def get_absolute_header_row(self) -> int:
        """Get the absolute row index of the header in the sheet."""
        return self.boundary.start_row + self.header_row


class MetadataSection(BaseModel):
    """A metadata/key-value section detected in the sheet."""
    section_id: str = Field(description="Unique identifier")
    start_row: int = Field(description="Starting row of metadata section")
    end_row: int = Field(description="Ending row of metadata section")
    entries: Dict[str, str] = Field(
        default_factory=dict,
        description="Key-value pairs extracted (e.g., {'Company': 'ABC Corp'})"
    )


class MultiTableAnalysis(BaseModel):
    """
    Complete analysis result for a sheet with multiple tables.
    Generated by the TableDetectionAgent.
    """
    file_name: str = Field(description="Source file name")
    sheet_name: str = Field(default="Sheet1", description="Analyzed sheet name")
    
    # Detection results
    tables: List[DetectedTable] = Field(
        default_factory=list,
        description="List of detected tables"
    )
    metadata_sections: List[MetadataSection] = Field(
        default_factory=list,
        description="Detected metadata/header sections"
    )
    
    # Summary stats
    total_tables_detected: int = Field(default=0)
    total_rows_in_sheet: int = Field(default=0)
    total_cols_in_sheet: int = Field(default=0)
    
    # Detection info
    detection_method: Literal["heuristic", "ai", "hybrid"] = Field(
        default="hybrid",
        description="Method used for detection"
    )
    overall_confidence: float = Field(
        default=0.8,
        ge=0.0,
        le=1.0,
        description="Overall confidence in detection results"
    )
    
    def get_table_by_id(self, table_id: str) -> Optional[DetectedTable]:
        """Find a table by its ID."""
        for table in self.tables:
            if table.table_id == table_id:
                return table
        return None
    
    def get_best_match_table(self) -> Optional[DetectedTable]:
        """Get the table with highest confidence."""
        if not self.tables:
            return None
        return max(self.tables, key=lambda t: t.confidence)
    
    def is_single_table(self) -> bool:
        """Check if only one table was detected."""
        return len(self.tables) == 1


class TableMatch(BaseModel):
    """Result of matching a detected table to a target schema."""
    table_id: str = Field(description="ID of the detected table")
    target_schema_name: str = Field(description="Name of the target schema")
    match_score: float = Field(
        ge=0.0,
        le=1.0,
        description="Overall match score (0.0 to 1.0)"
    )
    matched_columns: List[Tuple[str, str]] = Field(
        default_factory=list,
        description="List of (source_column, target_column) pairs"
    )
    unmatched_source_cols: List[str] = Field(
        default_factory=list,
        description="Source columns that didn't match any target"
    )
    unmatched_target_cols: List[str] = Field(
        default_factory=list,
        description="Required target columns without a source match"
    )
    
    @property
    def is_good_match(self) -> bool:
        """Check if this is considered a good match (>70%)."""
        return self.match_score >= 0.7


class TableMatchingResult(BaseModel):
    """Complete result of matching all detected tables to a target schema."""
    target_schema_name: str = Field(description="Name of target schema used")
    matches: List[TableMatch] = Field(
        default_factory=list,
        description="Match results for each detected table"
    )
    best_match_table_id: Optional[str] = Field(
        default=None,
        description="ID of the best matching table"
    )
    requires_user_selection: bool = Field(
        default=False,
        description="True if multiple good matches exist"
    )
    user_prompt: Optional[str] = Field(
        default=None,
        description="Question to ask user if selection is needed"
    )
    
    def get_best_match(self) -> Optional[TableMatch]:
        """Get the highest scoring match."""
        if not self.matches:
            return None
        return max(self.matches, key=lambda m: m.match_score)
    
    def get_good_matches(self, threshold: float = 0.7) -> List[TableMatch]:
        """Get all matches above the threshold."""
        return [m for m in self.matches if m.match_score >= threshold]
